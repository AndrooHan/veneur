syntax = "proto3";

package ssf;

// A Dimension (aka "tag") is a key-value pair that can be attached to
// an SSFSample or to an SSFSpan.
//
// Resolving Ambiguity
//
// Multiple Dimensions with the same key can be present, but if
// multiple Dimensions with the same key *and value* are present, SSF
// receivers must dedup (collapse them into a single Dimension) before
// reporting to the destination system.
//
// Some destination systems (particularly those in which dimensions
// are represented as a map) only support a single tag. For those
// systems, the first Dimension to be set "wins".
//
// Dimension target formats
//
// Most destination systems support dimensions in the shape of a list
// of strings attached to a span or metric, with "key:value"
// representing the natural representation of a Dimension with key and
// value filled. These destination systems tend to also support bare
// "value" dimensions (e.g. veneur's own "veneurglobalonly" tag).
//
// To represent these bare dimensions, an SSF Dimension should leave
// the key empty and set the value.
//
// Normalization of Tags
//
// Since Dimensions can appear on SSFSpans and SSFSamples alongside
// Tags, ingestion systems must normalize these tags into a coherent
// set of Dimensions, in the right order. To retrieve normalized
// Dimensions in the go library from a span or sample, use the
// AllDimensions() method.
//
// This method normalizes tags and dimensions by creating a new array
// containing any Tags, if they are set. Then, it appends the
// Dimensions already set on the span or sample.
//
// Note that Tags, when set, come first in the result aray - if any
// Tag is set, it overrides the value of the corresponding Dimension.
//
// Further normalization happens to "plain" tags: Tags with no value
// set are assumed to be "plain", and so their corresponding Dimension
// has an unset Key and the Tag's key set as the Value.
message Dimension {
  string key = 1;
  string value = 2;
}

// SSFSample is similar of a StatsD-style, point in time metric. It has a Metric
// type, a name, a value and a timestamp. Additionally it can contain a message,
// a status, a sample rate, a map of tags as string keys and values and a unit
// type. Note that SSF doesn't understand units, they are just strings!
message SSFSample {
  enum Metric {
      COUNTER = 0;
      GAUGE = 1;
      HISTOGRAM = 2;
      SET = 3;
      STATUS = 4;
  }
  enum Status {
      OK = 0;
      WARNING = 1;
      CRITICAL = 2;
      UNKNOWN = 3;
  }

  enum Scope {
    DEFAULT = 0;
    LOCAL = 1;
    GLOBAL = 2;
  }

  // The underlying type of the metric
  Metric metric = 1;

  // no spaces, but . is allowed
  // e.g.: veneur.bar.baz
  string name = 2;
  float value = 3;
  int64 timestamp = 4;
  string message = 5;
  Status status = 6;
  float sample_rate = 7;

  // Tags holds additional information about the SSFSample. It is
  // deprecated -- users of SSF should prefer to use Dimensions, as
  // they perform much better in encoding/decoding and more accurately
  // match destination systems' data models.
  //
  // Normalization
  //
  // When normalizing Dimensions, the Tags field's contents will be
  // gathered up first, which means that Dimensions with the same key
  // as those present on Tags can override their values.
  map<string, string> tags = 8;

  string unit = 9;

  // scope indicates to an SSF endpoint what it should do with a metric:
  //
  //     - DEFAULT (or absent) - aggregate counters and gauges locally,
  //       handle histograms and sets globally.
  //     - LOCAL - aggregate all metrics locally.
  //     - GLOBAL - aggregate all metrics globally.
  //
  Scope scope = 10;

  // Dimensions hold information about the SSFSample that can be used
  // by destination systems to e.g., keep separate time series. Users
  // should be aware that variable information on Dimensions usually
  // leads to higher cardinality in the destination system.
  repeated Dimension dimensions = 11;
}

// SSFSpan is the primary unit of reporting in SSF. It embeds a set of
// SSFSamples, as well as start/stop time stamps and a parent ID
// (which allows assembling a span lineage for distributed tracing
// purposes).
//
// Note that since this is protobuf, an SSFSpan does not *have* to
// include metrics, just as it does not *have* to include information
// necessary to reconstruct a trace.
//
// Compatibility
//
// On ingestion, an SSFSpan with an empty string for a name field but
// a tag "name" will have that name field replaced with the name tag,
// and the tag is removed.
//
// Metric SSFSamples with a zero sample_rate (indicating it was left
// out) have the sample_rate field set to 1 on ingestion.
//
// Validity Criteria
//
// Programs consuming SSFSpans should take care to only process spans
// and metrics that fulfill the following criteria:
//
// Metrics are considered valid if they have a name and a value.
//
// SSFSpans are considered valid trace spans if they have non-zero id,
// trace_id, start_timestamp and end_timestamp fields.
message SSFSpan {
  reserved 9;

  int32 version = 1;
  // the trace_id is the (span) id of the root span
  int64 trace_id = 2;
  // the id for this span
  int64 id = 3;
  // the (span) id of the direct parent, if this span is not a root
  // span
  int64 parent_id = 4;

  int64 start_timestamp = 5;
  int64 end_timestamp = 6;

  // This flag being true signals that this span was an error. That definition
  // of error is not implicitly fatal, as a span may error but be fixed by
  // a subsequent retry, etc.
  bool error = 7;

  // The name of the service
  // e.g. "veneur"
  string service = 8;

  repeated SSFSample metrics = 10;

  // Tags are name value pairs that describe a facet of the span. They apply to
  // the *entire* span as opposed to logs which apply to a specific time in
  // the span.
  //
  // The Tags field is deprecated - users of SSF are encouraged to use
  // the Dimensions field instead, as it encodes faster and allows
  // representing destination reprensentations of tags better.
  //
  // Normalization
  //
  // When normalizing Dimensions, the Tags field's contents will be
  // gathered up first, which means that Dimensions with the same key
  // as those present on Tags can override their values.
  map<string, string> tags = 11;

  // An indicator span is one that represents an action that is included in a
  // service's Service Level Indicators (https://en.wikipedia.org/wiki/Service_level_indicator)
  // This is a signal to receivers that this span may be used to compute SLIs.
  // In practice a service's core feature — the thing you would "bill" for, such
  // as an API call or read/write operation — would be flagged as an indicator
  // span, and its child spans would further describe its duration.
  // It's also worth nothing that an indicator need not be the "root" or first
  // span in a trace. You might have various forms of middleware that happen
  // first or you might have multiple services participating in the same trace.
  bool indicator = 12;

  // What to call this span. This could take the form of the endpoint
  // (/customer/:id), the function (class::name.method), a friendly name
  // (foo middleware) or whatever makes sense in your context.
  string name = 13;

  // Dimensions are name/value (or just plain value) pairs that
  // describe a facet of a span. They apply to the *entire* span and
  // are typically used for high-cardinality information, e.g.. to
  // hold information about the unit of work that the span describes.
  repeated Dimension dimensions = 14;
}
